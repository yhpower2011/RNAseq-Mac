#!/bin/bash
# RNA-seq processing pipeline for macOS Automator
# Author: Revised by ChatGPT on April 2025
# Ensure Automator uses /bin/bash for this script.

# Exit on any error, and treat undefined variables as errors:
set -euo pipefail

# Extend PATH for tools installed via Homebrew (adjust if needed)
export PATH="$PATH:/usr/local/bin:/opt/homebrew/bin"

# --------- CONFIGURATION ---------
# Number of CPU threads to use for multi-threaded tools:
threads=4  # Adjust based on your CPU cores for faster processing

# Paths to reference files (UPDATE these to your actual paths):
STAR_INDEX="/path/to/STAR/genome_index"    # STAR genome index directory
GTF_FILE="/path/to/annotation.gtf"         # Annotation GTF file for featureCounts and (optionally STAR)

# Adapter sequences for trimming (Illumina TruSeq adapters as default; update if different):
adapter_fwd="AGATCGGAAGAGCACACGTCTGAACTCCAGTCA"   # Adapter for read1 (3' end)
adapter_rev="AGATCGGAAGAGCGTCGTGTAGGGAAAGAGTGT"   # Adapter for read2 (3' end)

# Project folders to process:
projects=("RNAseq-a" "RNAseq-b" "RNAseq-c")
# ---------------------------------

echo "Starting RNA-seq pipeline..." 

for project in "${projects[@]}"; do
  if [ ! -d "$project" ]; then
    echo "Warning: Project directory '$project' not found, skipping."
    continue
  fi

  echo "== Processing project: $project =="
  cd "$project"

  # Create output directories if not present
  mkdir -p fastqc_raw trimmed star_out

  # Loop through each sample (paired-end FASTQ files)
  for R1 in *_R1.fastq.gz; do
    # Derive R2 filename from R1
    R2="${R1/_R1.fastq.gz/_R2.fastq.gz}"
    if [ ! -f "$R2" ]; then
      echo "Warning: Paired file for $R1 not found (expected $R2), skipping this sample."
      continue
    fi
    # Sample name (without _R1.fastq.gz suffix)
    sample="${R1%%_R1.fastq.gz}"
    echo "Processing sample: $sample"

    # --- Step 1: FastQC on raw reads ---
    # Check for FastQC outputs (.html report) for both R1 and R2
    if [ ! -f "fastqc_raw/${R1%%.fastq.gz}_fastqc.html" ] || [ ! -f "fastqc_raw/${R2%%.fastq.gz}_fastqc.html" ]; then
      echo "Running FastQC on raw reads for $sample..."
      fastqc --quiet -t 2 -o fastqc_raw "$R1" "$R2"&#8203;:contentReference[oaicite:1]{index=1}
      echo "FastQC completed for $sample"
    else
      echo "FastQC already done for $sample, skipping."
    fi

    # --- Step 2: Adapter trimming ---
    # Define trimmed output file names
    trimR1="trimmed/${sample}_R1_trimmed.fastq.gz"
    trimR2="trimmed/${sample}_R2_trimmed.fastq.gz"
    if [ ! -f "$trimR1" ] || [ ! -f "$trimR2" ]; then
      echo "Trimming adapters for $sample..."
      cutadapt -j $threads -a "$adapter_fwd" -A "$adapter_rev" -o "$trimR1" -p "$trimR2" "$R1" "$R2"
      echo "Trimming completed for $sample"
    else
      echo "Trimmed reads for $sample already exist, skipping."
    fi

    # --- Step 3: STAR alignment ---
    # Define STAR output BAM name (sorted BAM)
    aligned_bam="star_out/${sample}_Aligned.sortedByCoord.out.bam"
    if [ ! -f "$aligned_bam" ]; then
      echo "Aligning $sample with STAR..."
      STAR --runThreadN $threads \
           --genomeDir "$STAR_INDEX" \
           --readFilesIn "$trimR1" "$trimR2" \
           --readFilesCommand zcat \
           --outFileNamePrefix "star_out/${sample}_" \
           --outSAMtype BAM SortedByCoordinate \
           --outSAMunmapped Within \
           --quantMode TranscriptomeSAM   `# (optional: generates Transcriptome alignment if needed)` \
           --sjdbGTFfile "$GTF_FILE"       `# (optional: uses annotation to improve junction detection)` 
      echo "STAR alignment completed for $sample"
    else
      echo "STAR alignment for $sample already exists, skipping."
    fi

  done  # End of sample loop

  # --- Step 4: featureCounts (counting reads per gene) ---
  # featureCounts will produce a multi-sample count matrix for all BAMs in this project.
  counts_file="../${project}_counts.txt"   # output counts in parent directory (or use "$project_counts.txt" in same dir)
  # (Using parent directory so that each project's counts file is outside the project folder)
  if [ ! -f "$counts_file" ]; then
    # Check if there are BAM files to count
    bam_list=(star_out/*_Aligned.sortedByCoord.out.bam)
    if [ ${#bam_list[@]} -eq 0 ]; then
      echo "No aligned BAM files for $project, skipping featureCounts."
    else
      echo "Running featureCounts for project $project on ${#bam_list[@]} files..."
      featureCounts -T $threads -p -t exon -g gene_id -a "$GTF_FILE" -o "$counts_file" "${bam_list[@]}"&#8203;:contentReference[oaicite:2]{index=2}&#8203;:contentReference[oaicite:3]{index=3}
      echo "featureCounts completed for $project (output: ${project}_counts.txt)"
    fi
  else
    echo "featureCounts counts file already exists for $project, skipping."
  fi

  # --- Step 5: DESeq2 differential expression ---
  results_file="../${project}_deseq2_results.csv"
  if [ ! -f "$results_file" ]; then
    # Prepare sample names and condition labels from BAM filenames for DESeq2
    declare -a samples_list=() 
    declare -a cond_list=()
    for bam in star_out/*_Aligned.sortedByCoord.out.bam; do
      name="$(basename "$bam" _Aligned.sortedByCoord.out.bam)"
      samples_list+=("$name")
      # Derive condition from sample name by splitting at first underscore (e.g., Prefix_condition)
      # Adjust this logic if your sample naming convention is different.
      cond="${name%%_*}"
      cond_list+=("$cond")
    done
    echo "Running DESeq2 for $project (conditions: ${cond_list[*]})..."
    # Create an R script on the fly to run DESeq2
    Rscript --vanilla - <<EOF
library(DESeq2)
# Read the featureCounts output
counts <- read.table("${counts_file}", header=TRUE, row.names=1, comment.char="#")
# Remove annotation columns (Geneid, Chr, Start, End, Strand, Length) to keep only sample columns
counts <- counts[ , -(1:5)]
# Assign meaningful column names (sample IDs) to counts
sample_names <- c(${samples_list[@]/#\"/} )  # placeholder, will be replaced by bash (see below)
# ^^^ NOTE: This placeholder will be replaced by bash string substitution below.
EOF
    # The above Rscript here-doc is incomplete; we will inject the actual vectors next.
    # We do this in two parts to safely insert bash arrays into R vectors.

    # Build R vector strings for samples and conditions
    sample_vec=$(printf '"%s", ' "${samples_list[@]}")
    sample_vec=${sample_vec%, }  # remove trailing comma
    cond_vec=$(printf '"%s", ' "${cond_list[@]}")
    cond_vec=${cond_vec%, }

    # Complete the R script with proper sample and condition vectors
    Rscript --vanilla - <<EOF
library(DESeq2)
# Prepare count matrix:
counts <- read.table("${counts_file}", header=TRUE, row.names=1, comment.char="#")
counts <- counts[ , -(1:5)]
# Define sample names and conditions:
samples <- c(${sample_vec})
conditions <- factor(c(${cond_vec}))
colnames(counts) <- samples
# Create DESeq2 dataset
coldata <- data.frame(condition=conditions, row.names=samples)
dds <- DESeqDataSetFromMatrix(countData=counts, colData=coldata, design=~condition)
dds <- DESeq(dds)
res <- results(dds)
# Order results by adjusted p-value
res <- res[order(res\$padj), ]
# Write results to CSV
write.csv(as.data.frame(res), file="${results_file}")
EOF
    echo "DESeq2 analysis completed for $project (results: ${project}_deseq2_results.csv)"
  else
    echo "DESeq2 results already exist for $project, skipping."
  fi

  # Return to base directory before next project
  cd ..
  echo "Finished project: $project"
done

echo "All projects finished successfully."
